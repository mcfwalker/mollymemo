# LazyList v0.1 Design

**Date:** 2026-01-25
**Status:** Approved for implementation

## Overview

LazyList is a personal knowledge capture system that accepts links (primarily from phone), extracts intelligence, auto-categorizes, and stores for later retrieval via Claude Code skill.

### Design Principles

1. **Fire and forget** — Share a link, get confirmation, never think about it again
2. **Zero cognitive burden** — Software handles everything; user reviews only when they want to
3. **Low stakes** — Miscategorization is fine; fix later or never
4. **Tight scope, production quality** — Small feature set, robust implementation

### Use Cases

- Scrolling TikTok, see a useful coding technique → share → captured
- Find a GitHub repo → share → captured with metadata
- Working on qwkshot → run `/lazylist` → see relevant captured items
- (Future) Morning voice briefing of new items relevant to active projects

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│  CAPTURE                                                     │
│  iOS Shortcut → POST to /api/capture                        │
│  (Hosted on Vercel/Railway - always available)              │
└──────────────────────┬──────────────────────────────────────┘
                       ▼
┌─────────────────────────────────────────────────────────────┐
│  PROCESSING (async)                                          │
│  - Detect URL type (TikTok, GitHub, article)                │
│  - TikTok: ElevenLabs transcription → AI extraction         │
│  - GitHub: gh API for metadata                              │
│  - Article: Fetch content → AI extraction                   │
│  - AI classifies: domain + content type + tags              │
└──────────────────────┬──────────────────────────────────────┘
                       ▼
┌─────────────────────────────────────────────────────────────┐
│  STORAGE                                                     │
│  Supabase (Postgres)                                        │
│  - Always available                                          │
│  - Queryable via Supabase MCP from Claude Code              │
└──────────────────────┬──────────────────────────────────────┘
                       ▼
┌─────────────────────────────────────────────────────────────┐
│  INTERFACES                                                  │
│  - Web UI: Browse, search, recategorize                     │
│  - /lazylist skill: Query from Claude Code                  │
│  - iOS: "✓ Captured: [title]" confirmation                  │
└─────────────────────────────────────────────────────────────┘
```

## Tech Stack

| Component | Technology | Reason |
|-----------|------------|--------|
| Database | Supabase (Postgres) | Always on, MCP integration, free tier sufficient |
| Backend | Next.js API routes | Simple, deploys to Vercel easily |
| Frontend | Next.js + React | Same codebase as API |
| Hosting | Vercel | Free tier, always on, easy deploys |
| Transcription | ElevenLabs API | TikTok URL → transcript |
| AI Analysis | Gemini 2.0 Flash | Fast, cheap, good enough |
| Phone Access | Tailscale (optional) | If local dev needed |

## Data Model

```sql
CREATE TABLE items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Source
  source_url TEXT NOT NULL,
  source_type TEXT NOT NULL, -- 'tiktok', 'github', 'article', 'youtube'

  -- Extracted content
  title TEXT,
  summary TEXT,
  transcript TEXT, -- Full transcript for TikTok/video
  extracted_entities JSONB, -- { repos: [], tools: [], techniques: [] }

  -- Classification
  domain TEXT, -- 'vibe-coding', 'ai-filmmaking', 'other'
  content_type TEXT, -- 'repo', 'technique', 'tool', 'resource', 'person'
  tags TEXT[],

  -- GitHub-specific (when content_type = 'repo')
  github_url TEXT,
  github_metadata JSONB, -- { stars, language, description, topics }

  -- Meta
  captured_at TIMESTAMPTZ DEFAULT NOW(),
  processed_at TIMESTAMPTZ,
  status TEXT DEFAULT 'pending', -- 'pending', 'processing', 'processed', 'failed'
  error_message TEXT, -- If status = 'failed'

  -- Future-proofing
  raw_data JSONB, -- Everything we fetched, for reprocessing
  embeddings VECTOR(1536) -- For semantic search later
);

-- Indexes
CREATE INDEX idx_items_status ON items(status);
CREATE INDEX idx_items_domain ON items(domain);
CREATE INDEX idx_items_content_type ON items(content_type);
CREATE INDEX idx_items_captured_at ON items(captured_at DESC);
CREATE INDEX idx_items_source_url ON items(source_url); -- Duplicate detection
```

## Processing Pipeline

### 1. Capture (sync, instant response)

```
POST /api/capture
Body: { "url": "https://..." }

→ Validate URL format
→ Check for duplicate (same source_url in last 24h)
→ INSERT with status='pending'
→ Trigger async processing
→ Return { id, status: "captured" }
```

### 2. Detect Source Type

| URL Pattern | Source Type |
|-------------|-------------|
| `tiktok.com/*`, `vm.tiktok.com/*` | tiktok |
| `github.com/*/*` | github |
| `youtube.com/*`, `youtu.be/*` | youtube |
| Everything else | article |

### 3. Extract (source-specific)

**TikTok:**
```
1. Call ElevenLabs Speech-to-Text API with TikTok URL
2. Store full transcript
3. Send transcript to Gemini:
   "Extract any GitHub repos, tools, products, or techniques mentioned.
    Return as JSON: { repos: [], tools: [], techniques: [] }"
4. For each GitHub URL found → fetch metadata via GitHub API
```

**GitHub:**
```
1. Fetch repo metadata via GitHub API:
   - name, description, stars, language, topics
2. Send to Gemini for summary + categorization
```

**Article:**
```
1. Fetch page content (handle JS-rendered pages if needed)
2. Send to Gemini:
   "Extract title, summary, and any tools/repos/techniques mentioned"
```

### 4. Classify

Single Gemini call with all extracted content:

```
Given this content, classify it:

Title: {title}
Summary: {summary}
Entities found: {extracted_entities}
Source: {source_type}

1. Domain (pick one): vibe-coding, ai-filmmaking, other
2. Content type (pick one): repo, technique, tool, resource, person
3. Tags (up to 5): relevant keywords

Return as JSON.
```

### 5. Store

Update the database record:
- Set all extracted/classified fields
- Set `status = 'processed'`
- Set `processed_at = NOW()`

On failure:
- Set `status = 'failed'`
- Set `error_message` with details
- Keep the record for manual review or retry

## Web UI

Minimal interface for browsing and recategorization.

### Main View

```
┌─────────────────────────────────────────────────────────────┐
│  LazyList                                    [Search...]    │
├─────────────────────────────────────────────────────────────┤
│  [All Domains ▾] [All Types ▾] [All Status ▾]              │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ cursor-tools                         [vibe-coding ▾]│   │
│  │ AI-powered CLI for cursor editor            ● repo  │   │
│  │ ★ 2.3k  TypeScript              2 hours ago        │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                              │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ "Use structured outputs..."          [vibe-coding ▾]│   │
│  │ Technique for reliable JSON from LLMs  ● technique  │   │
│  │ via @aidev_tips TikTok              yesterday       │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Interactions

- **Search:** Filters list in real-time
- **Domain dropdown:** Click → select → saves instantly (no submit button)
- **Click item:** Expands to show full details, transcript, source link
- **Filters:** Dropdowns for domain, content_type, status

### No cruft

- No dashboard
- No analytics
- No "items this week"
- No onboarding
- No settings page (configure via env vars)

## Skill: `/lazylist`

Claude Code skill that queries the database for relevant items.

### Location

`~/.claude/skills/lazylist/SKILL.md`

### Behavior

1. Read current project context (CLAUDE.md, package.json, recent files)
2. Determine what the project is about
3. Query Supabase via MCP:
   - Text search on title, summary, tags
   - Filter by relevant domains
   - Order by relevance/recency
4. Present top 5-10 matches with:
   - Title + type badge
   - Why it might be relevant
   - Key metadata (stars for repos, source for TikToks)
5. Offer to dive deeper into any item

### Example Output

```
Searching LazyList for items relevant to qwkshot (3D visualization)...

Found 3 potentially useful items:

1. **theatre-js** [repo] ★ 12k
   Motion design editor with timeline UI — good for camera path editing inspiration
   github.com/theatre-js/theatre

2. **"Bezier curves for camera paths"** [technique]
   From @3ddev TikTok — approach for smooth camera interpolation
   Captured 1 week ago

3. **Spline** [tool]
   Web-based 3D design tool with React integration
   spline.design

Want details on any of these?
```

## iOS Shortcut

### Setup

1. Create shortcut named "LazyList"
2. Accept Share Sheet input (URLs)
3. Action: POST to `https://lazylist-[username].vercel.app/api/capture`
   - Header: `Authorization: Bearer [API_KEY]`
   - Body: `{ "url": "[Shortcut Input]" }`
4. Show notification: "✓ Captured"

### Security

- Simple Bearer token auth (stored in Shortcut)
- Rate limiting: 100 requests/hour per token
- URL validation on server

## API Endpoints

### `POST /api/capture`

Capture a new URL.

```
Headers:
  Authorization: Bearer <token>

Body:
  { "url": "https://..." }

Response:
  { "id": "uuid", "status": "captured" }
```

### `GET /api/items`

List items with filtering.

```
Query params:
  - domain: filter by domain
  - type: filter by content_type
  - status: filter by status
  - q: text search
  - limit: max results (default 50)
  - offset: pagination

Response:
  { "items": [...], "total": 123 }
```

### `PATCH /api/items/:id`

Update an item (for recategorization).

```
Body:
  { "domain": "ai-filmmaking" }

Response:
  { "id": "uuid", "domain": "ai-filmmaking", ... }
```

## Environment Variables

```
# Supabase
SUPABASE_URL=https://xxx.supabase.co
SUPABASE_SERVICE_KEY=xxx

# APIs
ELEVENLABS_API_KEY=xxx
GEMINI_API_KEY=xxx
GITHUB_TOKEN=xxx  # For higher rate limits

# Auth
API_SECRET_KEY=xxx  # For iOS Shortcut auth
```

## Project Structure

```
lazylist/
├── docs/
│   └── plans/
│       └── 2026-01-25-lazylist-v0.1-design.md
├── src/
│   ├── app/
│   │   ├── api/
│   │   │   ├── capture/route.ts
│   │   │   └── items/route.ts
│   │   ├── page.tsx          # Main UI
│   │   └── layout.tsx
│   ├── lib/
│   │   ├── supabase.ts       # DB client
│   │   ├── processors/
│   │   │   ├── tiktok.ts
│   │   │   ├── github.ts
│   │   │   └── article.ts
│   │   ├── classifier.ts     # AI categorization
│   │   └── elevenlabs.ts     # Transcription client
│   └── components/
│       ├── ItemCard.tsx
│       ├── ItemList.tsx
│       └── Filters.tsx
├── package.json
├── CLAUDE.md
└── README.md
```

## Out of Scope for v0.1

- Embeddings/semantic search
- Voice briefings
- YouTube support (similar to TikTok, add later)
- Duplicate detection UI (just prevent in API)
- Batch recategorization
- Export functionality
- Multi-user support

## Success Criteria

1. Share TikTok link from phone → appears in DB within 60 seconds
2. Share GitHub link from phone → appears with metadata within 30 seconds
3. Web UI loads items, allows domain change with single click
4. `/lazylist` skill finds relevant items for current project
5. System runs unattended with no required maintenance

---

## Next Steps

1. Create Supabase project + table
2. Scaffold Next.js app
3. Implement capture endpoint
4. Implement TikTok processor (ElevenLabs integration)
5. Implement GitHub processor
6. Build minimal web UI
7. Create iOS Shortcut
8. Create `/lazylist` skill
9. Deploy to Vercel
